<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZXY影视网站 - AI 焕新版 (多源搜索)</title>
    <style>
        /* --- Reset & Basic Styles --- */
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        :root {
            /* --- Light Theme Colors --- */
            --primary-color: #007bff; /* 主题蓝 */
            --primary-color-darker: #0056b3;
            --background-color: #f8f9fa; /* 页面背景色 */
            --surface-color: #ffffff; /* 卡片、Header 背景色 */
            --text-color: #212529; /* 主要文字颜色 */
            --text-muted: #6c757d; /* 次要文字颜色 */
            --border-color: #dee2e6; /* 边框颜色 */
            --hover-bg-color: #e9ecef; /* 悬停背景色 (浅灰) */
            --shadow-color: rgba(0, 0, 0, 0.1); /* 阴影颜色 */
            --source-badge-bg: #6c757d; /* 来源标签背景色 */
            --source-badge-color: #fff; /* 来源标签文字颜色 */


            /* --- Style Variables --- */
            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            --card-shadow: 0 4px 12px var(--shadow-color);
            --card-hover-shadow: 0 8px 20px rgba(0, 0, 0, 0.12);
            --border-radius: 8px;
            --transition-speed: 0.3s;
        }

        html {
             scroll-behavior: smooth; /* 平滑滚动效果 */
        }

        body {
            font-family: var(--font-family);
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            transition: background-color var(--transition-speed) ease; /* 背景色平滑过渡 */
        }

        /* --- Layout --- */
        .container {
            width: 90%;
            max-width: 1280px; /* Slightly wider max-width */
            margin: 0 auto;
            padding: 0 15px; /* Add horizontal padding */
        }

        header {
            background-color: var(--surface-color);
            border-bottom: 1px solid var(--border-color); /* Use border instead of shadow */
            padding: 12px 0;
            position: sticky;
            top: 0;
            z-index: 1000;
            transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease;
            /* display: none; */ /* Managed by JS now */
        }

        main {
            flex-grow: 1;
            padding: 30px 0;
            display: flex; /* Use flex for centering initial search */
            flex-direction: column;
        }

        footer {
            background-color: var(--surface-color);
            color: var(--text-muted);
            text-align: center;
            padding: 20px 0;
            margin-top: auto; /* Pushes footer to the bottom */
            font-size: 0.9em;
            border-top: 1px solid var(--border-color);
            transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease;
        }

        /* --- Header Elements --- */
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap; /* Allow wrap on smaller screens */
        }

        .logo {
            font-size: 1.8em;
            font-weight: bold;
            color: var(--primary-color);
            text-decoration: none;
            transition: color var(--transition-speed) ease;
        }
        .logo:hover {
            color: var(--primary-color-darker);
        }

        .search-form { /* Style for header search form */
            display: flex;
            max-width: 450px;
            width: 100%;
            margin-left: 20px; /* Space from logo */
        }

        .search-input {
            flex-grow: 1;
            padding: 10px 15px;
            border: 1px solid var(--border-color);
            border-right: none; /* Join with button */
            border-radius: var(--border-radius) 0 0 var(--border-radius);
            background-color: var(--surface-color);
            color: var(--text-color);
            font-size: 1em;
            outline: none;
            transition: border-color var(--transition-speed) ease, background-color var(--transition-speed) ease, box-shadow var(--transition-speed) ease;
        }
        .search-input:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
            z-index: 2; /* Ensure shadow is visible */
            position: relative; /* Needed for z-index */
        }

        .search-button {
            padding: 10px 20px;
            border: 1px solid var(--primary-color);
            background-color: var(--primary-color);
            color: white;
            cursor: pointer;
            border-radius: 0 var(--border-radius) var(--border-radius) 0;
            font-size: 1em;
            transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease;
        }
        .search-button:hover {
            background-color: var(--primary-color-darker);
            border-color: var(--primary-color-darker);
        }

        /* --- Initial Centered Search Area --- */
        #initial-search-area {
            display: flex;
            flex-direction: column;
            justify-content: center; /* Vertical centering */
            align-items: center; /* Horizontal centering */
            flex-grow: 1; /* Take available vertical space */
            text-align: center;
            padding: 40px 15px;
        }
        #initial-search-area .logo {
             font-size: 3em; /* Larger logo */
             margin-bottom: 30px;
        }
        #initial-search-area .search-form {
            max-width: 600px; /* Wider search bar */
            width: 100%;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08); /* Subtle shadow */
            border-radius: var(--border-radius);
            margin-left: 0; /* Reset margin */
        }
        #initial-search-area .search-input {
            font-size: 1.1em; /* Slightly larger text */
            padding: 15px 20px;
            border: 1px solid var(--border-color); /* Ensure border is visible */
            border-right: none;
        }
        #initial-search-area .search-button {
            font-size: 1.1em;
            padding: 15px 25px;
        }
         #initial-search-area .search-input:focus { /* Specific focus for initial search */
              border-color: var(--primary-color);
              box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
              z-index: 2;
              position: relative;
         }

        /* --- Player Area --- */
        #player-area {
            margin-bottom: 40px; /* More space */
            position: relative;
            padding-top: 56.25%; /* 16:9 Aspect Ratio */
            background-color: #000; /* Black background for player */
            border-radius: var(--border-radius);
            overflow: hidden;
            display: none; /* Initially hidden */
            box-shadow: 0 6px 15px rgba(0,0,0,0.15);
        }
        #player-area iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
        }
         #player-placeholder {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column; /* Stack text and retry info */
            justify-content: center;
            align-items: center;
            color: #ccc; /* Light text on black background */
            background-color: rgba(0, 0, 0, 0.7);
            font-size: 1.2em;
            z-index: 1; /* Above iframe while loading */
            transition: opacity var(--transition-speed) ease;
            text-align: center;
            padding: 10px;
         }
         #player-placeholder .retry-info {
             font-size: 0.8em;
             color: #aaa;
             margin-top: 10px;
         }


        /* --- Search Results --- */
        #results-area {
            /* display: none; */ /* Managed by JS now */
            padding-top: 20px;
        }
        #results-area h2.section-title { /* Optional title for results */
            margin-bottom: 25px;
            color: var(--text-color);
            font-weight: 600;
            border-bottom: 3px solid var(--primary-color);
            padding-bottom: 8px;
            display: inline-block;
        }
        #results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 25px; /* Increased gap */
        }

        .result-card {
            background-color: var(--surface-color);
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: var(--card-shadow);
            transition: transform var(--transition-speed) ease, box-shadow var(--transition-speed) ease;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            border: 1px solid var(--border-color); /* Subtle border */
        }
        .result-card:hover {
            transform: translateY(-6px);
            box-shadow: var(--card-hover-shadow);
        }

        .card-image {
            position: relative;
            padding-top: 140%; /* Aspect ratio for posters */
            background-color: var(--hover-bg-color); /* Placeholder color */
            background-size: cover;
            background-position: center;
            overflow: hidden; /* Ensure episode info stays inside */
        }
        .card-image .episode-info {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background-color: rgba(0, 0, 0, 0.75); /* Slightly darker badge */
            color: white;
            padding: 3px 8px;
            font-size: 0.8em;
            border-radius: 4px;
            font-weight: 500;
        }

        .card-content {
            padding: 12px 15px; /* Adjust padding */
            flex-grow: 1;
            display: flex; /* Helps align title if needed */
            flex-direction: column;
            position: relative; /* For source badge positioning */
        }
        .card-title {
            font-size: 1em;
            font-weight: 600;
            color: var(--text-color);
            margin-bottom: 5px;
            line-height: 1.4;
            /* Clamp text to 2 lines */
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            min-height: 2.8em; /* Ensure space for two lines (adjust based on line-height) */
            transition: color var(--transition-speed) ease;
        }
        .result-card:hover .card-title {
            color: var(--primary-color); /* Highlight title on hover */
        }
        .source-badge {
             position: absolute;
             top: 8px;
             right: 8px;
             background-color: var(--source-badge-bg);
             color: var(--source-badge-color);
             font-size: 0.7em;
             padding: 2px 6px;
             border-radius: 3px;
             font-weight: 500;
        }

        /* --- Loading & Messages --- */
        #loading, #message {
            text-align: center;
            margin: 50px 0;
            padding: 20px;
            font-size: 1.1em;
            border-radius: var(--border-radius);
        }
        #loading {
             display: none; /* Hidden initially */
             color: var(--text-muted);
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1); /* Lighter border for light theme */
            border-radius: 50%;
            border-top: 4px solid var(--primary-color);
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px auto; /* Centered with space below */
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .error-message {
            color: #dc3545; /* Red for errors */
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            font-weight: bold;
        }
        .info-message {
            color: var(--text-muted);
            background-color: #e2e3e5;
            border: 1px solid var(--border-color);
        }

        /* --- Responsive Adjustments --- */
        @media (max-width: 768px) {
             .header-content {
                 flex-direction: column;
                 align-items: center; /* Center items when stacked */
             }
             .logo { margin-bottom: 10px; } /* Space below logo when stacked */
             .search-form {
                 max-width: none; /* Full width on smaller screens */
                 margin-top: 10px;
                 margin-left: 0; /* Remove left margin */
             }
             #results-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
                gap: 20px;
            }
            .card-title {
                font-size: 0.95em;
                min-height: 2.7em;
            }
            #initial-search-area .logo {
                 font-size: 2.5em;
            }
            #initial-search-area .search-form {
                 max-width: 95%;
            }
             .source-badge { font-size: 0.65em; }
        }
         @media (max-width: 480px) {
             #results-grid {
                /* Adjust columns for very small screens */
                grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
                gap: 15px;
            }
             .card-title {
                font-size: 0.9em;
                min-height: 2.6em;
             }
             .container {
                 width: 95%;
                 padding: 0 10px;
             }
              #initial-search-area .logo {
                  font-size: 2.2em;
              }
              #initial-search-area .search-input,
              #initial-search-area .search-button {
                   font-size: 1em;
                   padding: 12px 15px;
              }
              #initial-search-area .search-button {
                   padding: 12px 20px;
              }
               .search-input, .search-button { /* Adjust header search on small screens */
                    font-size: 0.9em;
                    padding: 8px 12px;
               }
               .search-button { padding: 8px 15px; }
               .source-badge { font-size: 0.6em; }
         }
    </style>
</head>
<body>
    <!-- Standard Header -->
    <header id="main-header" style="display: none;"> <!-- Start hidden -->
        <div class="container header-content">
            <a href="#" class="logo" onclick="showInitialView(); return false;">ZXY影视</a> <!-- Go back to initial view -->
            <form id="header-search-form" class="search-form">
                <input type="text" id="header-search-input" class="search-input" placeholder="再次搜索..." required>
                <button type="submit" class="search-button">搜索</button>
            </form>
        </div>
    </header>

    <main class="container">
        <!-- Initial Centered Search -->
        <div id="initial-search-area">
             <a href="#" class="logo" onclick="showInitialView(); return false;">ZXY影视</a>
             <form id="initial-search-form" class="search-form">
                <input type="text" id="initial-search-input" class="search-input" placeholder="搜索电影、剧集..." required autofocus>
                <button type="submit" class="search-button">搜索</button>
            </form>
        </div>

        <!-- Player Area (Remains Hidden Initially) -->
        <div id="player-area">
            <div id="player-placeholder">
                <span class="main-text">在此处播放视频...</span>
                <span class="retry-info" style="display: none;"></span>
            </div>
            <iframe id="video-player" frameborder="0" allowfullscreen></iframe>
        </div>

        <!-- Results Area (Remains Hidden Initially) -->
        <div id="results-area" style="display: none;"> <!-- Start hidden -->
            <div id="loading">
                <div class="spinner"></div>
                正在从多个来源搜索，请稍候...
            </div>
            <div id="message" class="info-message">输入关键词搜索您想看的影视内容。</div>
            <div id="results-grid">
                <!-- Search results will be populated here -->
            </div>
        </div>
    </main>

    <footer>
        <div class="container">
            &copy; 2025 ZXY影视网站. 仅供学习交流，请尊重版权。
        </div>
    </footer>

    <script>
        // --- DOM Elements ---
        const initialSearchArea = document.getElementById('initial-search-area');
        const initialSearchForm = document.getElementById('initial-search-form');
        const initialSearchInput = document.getElementById('initial-search-input');

        const mainHeader = document.getElementById('main-header');
        const headerSearchForm = document.getElementById('header-search-form');
        const headerSearchInput = document.getElementById('header-search-input');

        const resultsArea = document.getElementById('results-area');
        const resultsGrid = document.getElementById('results-grid');
        const loadingIndicator = document.getElementById('loading');
        const messageArea = document.getElementById('message');
        const playerArea = document.getElementById('player-area');
        const playerIframe = document.getElementById('video-player');
        const playerPlaceholder = document.getElementById('player-placeholder');
        const playerPlaceholderText = playerPlaceholder.querySelector('.main-text');
        const playerPlaceholderRetryInfo = playerPlaceholder.querySelector('.retry-info');


        // --- Configuration ---
        const PROXY_BASE_URL = 'http://localhost:3000'; // 确保这与你的 server.js 端口一致
        const EXTERNAL_PLAYER_BASE_URL = 'https://b.212133.xyz/player/ec.php?code=qw&if=1&url=';

        // --- Search Sources ---
        const SEARCH_SOURCES = [
            {
                id: 'original', // 给你的原始来源起个ID
                name: '主源', // 显示在卡片上的名称
                proxySearchEndpoint: '/search-source-original' // 代理服务器上对应的搜索端点
            },
            {
                id: 'fsyuyou',
                name: '飞速', // 显示在卡片上的名称
                proxySearchEndpoint: '/search-source-fsyuyou' // 代理服务器上对应的搜索端点
            }
            // 可以继续添加更多来源
        ];

        // --- AI Configuration ---
        // !!! 安全警告: 将 API Key 直接放在前端非常不安全，极易泄露 !!!
        // !!! 强烈建议通过后端代理调用 AI API !!!
        const AI_API_URL = 'https://ark.cn-beijing.volces.com/api/v3/chat/completions'; // 确认这个 Chat API Endpoint 是否正确
        const AI_API_KEY = 'd0a7363d-cd63-4902-9a16-49737bc17b5e'; // 你的 API Key
        const AI_MODEL = 'deepseek-v3-250324';
        const AI_MAX_TOKENS = 16000;
        const AI_TEMPERATURE = 0.1;

        // --- Retry Configuration ---
        const MAX_RETRIES = 3;
        const RETRY_DELAY_MS = 1000; // 1秒延迟

        // --- State Management ---
        function showInitialView() {
            initialSearchArea.style.display = 'flex';
            mainHeader.style.display = 'none';
            resultsArea.style.display = 'none';
            playerArea.style.display = 'none';
            playerIframe.src = 'about:blank'; // Clear player
            // Reset search inputs if needed
            initialSearchInput.value = '';
            headerSearchInput.value = '';
        }

        function showResultsView() {
            initialSearchArea.style.display = 'none';
            mainHeader.style.display = 'flex'; // Use flex for alignment
            resultsArea.style.display = 'block'; // Show results area
            // Player is handled separately when a result is clicked
        }

        // --- UI Functions ---
        function showLoading(show = true) {
            loadingIndicator.style.display = show ? 'block' : 'none';
            if (show) {
                messageArea.style.display = 'none';
                resultsGrid.innerHTML = ''; // 清空结果区域
            }
        }

        function showMessage(text, isError = false) {
            messageArea.textContent = text;
            messageArea.className = `message ${isError ? 'error-message' : 'info-message'}`;
            messageArea.style.display = 'block';
            resultsGrid.innerHTML = ''; // 清空结果
            showLoading(false);
        }

        function updatePlayerPlaceholder(text, isError = false, retryAttempt = 0, maxRetries = 0) {
            playerPlaceholderText.textContent = text;
            playerPlaceholderText.style.color = isError ? '#dc3545' : '#ccc';
            if (retryAttempt > 0 && isError) {
                 playerPlaceholderRetryInfo.textContent = `(尝试 ${retryAttempt}/${maxRetries} - ${text.includes('AI') ? 'AI处理' : '获取页面'}失败，1秒后重试...)`;
                 playerPlaceholderRetryInfo.style.display = 'block';
            } else {
                 playerPlaceholderRetryInfo.style.display = 'none';
            }
            playerPlaceholder.style.opacity = '1';
            playerPlaceholder.style.display = 'flex';
        }

        // --- Helper: Delay Function ---
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // --- Helper: Fetch with Retry ---
        async function fetchWithRetry(url, options = {}, maxRetries = MAX_RETRIES, currentAttempt = 1) {
            try {
                console.log(`[Fetch Retry] Attempt ${currentAttempt}/${maxRetries} for ${url}`);
                const response = await fetch(url, options);
                if (!response.ok) {
                    // Throw an error for non-successful HTTP status codes to trigger retry
                    throw new Error(`HTTP error ${response.status}: ${response.statusText}`);
                }
                return response; // Success
            } catch (error) {
                console.warn(`[Fetch Retry] Attempt ${currentAttempt} failed for ${url}:`, error.message);
                if (currentAttempt < maxRetries) {
                    await delay(RETRY_DELAY_MS);
                    return fetchWithRetry(url, options, maxRetries, currentAttempt + 1); // Retry
                } else {
                    console.error(`[Fetch Retry] All ${maxRetries} attempts failed for ${url}.`);
                    throw error; // Rethrow the error after all retries failed
                }
            }
        }

        // --- Helper: AI Call with Retry ---
        async function callAIWithRetry(htmlContent, title, maxRetries = MAX_RETRIES, currentAttempt = 1) {
            console.log(`[AI Retry] Attempt ${currentAttempt}/${maxRetries} to analyze: ${title}`);
            updatePlayerPlaceholder(`② 请求 AI 分析页面 (尝试 ${currentAttempt}/${maxRetries}): ${title}...`);

            try {
                // !!! SECURITY WARNING: Exposing API Key here is highly insecure !!!
                const aiResponse = await fetch(AI_API_URL, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${AI_API_KEY}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: AI_MODEL,
                        messages: [
                            {
                                role: "system",
                                content: "You are an expert web scraper. Your task is to extract the primary video stream URL (usually ending in .m3u8) from the given HTML content. Respond ONLY with the URL itself, without any introductory text, explanations, or formatting like backticks or quotes."
                            },
                            {
                                role: "user",
                                content: `Extract the video stream URL (e.g., https://.../video.m3u8) from this HTML:\n\n\`\`\`html\n${htmlContent.substring(0, 15000)}\n\`\`\`\n\nReturn only the URL.` // Limit HTML size slightly for safety
                            }
                        ],
                        max_tokens: AI_MAX_TOKENS, // Adjusted for URL extraction
                        temperature: AI_TEMPERATURE,
                        stream: false
                    })
                });

                if (!aiResponse.ok) {
                    const errorBody = await aiResponse.text();
                    console.error(`[AI Retry] AI API Error (Attempt ${currentAttempt}): ${aiResponse.status} ${aiResponse.statusText}`, errorBody);
                    throw new Error(`AI API 请求失败: ${aiResponse.status}`);
                }

                const aiResult = await aiResponse.json();

                if (!aiResult.choices || aiResult.choices.length === 0 || !aiResult.choices[0].message || !aiResult.choices[0].message.content) {
                    console.error(`[AI Retry] Invalid AI response structure (Attempt ${currentAttempt}):`, aiResult);
                    throw new Error('AI 返回了无效的数据结构');
                }

                let streamUrl = aiResult.choices[0].message.content.trim();
                console.log(`[AI Retry] Raw AI response (Attempt ${currentAttempt}): "${streamUrl}"`);
                streamUrl = streamUrl.replace(/^["'`]+|["'`]+$/g, ''); // Clean quotes/backticks
                streamUrl = streamUrl.replace(/^URL:\s*/i, ''); // Clean prefix

                // *** Crucial Validation for Retry ***
                if (!streamUrl || (!streamUrl.startsWith('http') && !streamUrl.startsWith('/')) || !streamUrl.includes('.m3u8')) { // Added .m3u8 check
                    console.warn(`[AI Retry] Invalid or non-M3U8 URL extracted (Attempt ${currentAttempt}): "${streamUrl}"`);
                    throw new Error(`AI 未能提取有效的 .m3u8 链接`);
                }

                console.log(`[AI Retry] Valid Stream URL Extracted (Attempt ${currentAttempt}): "${streamUrl}"`);
                return streamUrl.replace(/\\\//g, '/'); // Return cleaned, valid URL

            } catch (error) {
                console.warn(`[AI Retry] Attempt ${currentAttempt} failed for ${title}:`, error.message);
                 updatePlayerPlaceholder(error.message, true, currentAttempt, maxRetries); // Show retry info in placeholder
                if (currentAttempt < maxRetries) {
                    await delay(RETRY_DELAY_MS);
                    return callAIWithRetry(htmlContent, title, maxRetries, currentAttempt + 1); // Retry
                } else {
                    console.error(`[AI Retry] All ${maxRetries} AI attempts failed for ${title}.`);
                    throw new Error(`AI 分析失败 (${maxRetries}次尝试): ${error.message}`); // Final error
                }
            }
        }

        // --- Parsing and Display Logic ---
        function parseAndAddResults(htmlContent, source, targetGrid) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlContent, 'text/html');
            let itemsAdded = 0;

            // Common selectors - adjust if sources differ significantly
            const itemSelectors = ['.stui-vodlist__media > li', '.stui-vodlist > li', '.myui-vodlist__box', '.vodlist_item']; // Added generic .vodlist_item
            let items = [];
            for (const selector of itemSelectors) {
                items = doc.querySelectorAll(selector);
                if (items.length > 0) break;
            }

            console.log(`[Parse] Found ${items.length} potential items from ${source.name} using selectors:`, itemSelectors);

            items.forEach((item, index) => {
                try {
                    // Adapt selectors based on potential variations
                    const titleElement = item.querySelector('.title a, h3 a, .detail h3 a, .vodlist_title a');
                    const imgElement = item.querySelector('.thumb a.v-thumb, .myui-vodlist__thumb, .lazyload, .vodlist_thumb img');
                    const playButton = item.querySelector('.detail p.margin-0 a.btn-primary, a[href*="/play/"], a[href*="/kan/"], a.vodlist_play'); // Check for play link more broadly
                    const episodeInfoElement = item.querySelector('.thumb .pic-text, .pic-text, .jidi, .vodlist_sub');

                    if (titleElement && imgElement && playButton && playButton.getAttribute('href')) {
                        const title = titleElement.textContent.trim();
                        // Prioritize 'data-original', 'data-src', then 'src'
                        let coverUrl = imgElement.dataset.original || imgElement.dataset.src || imgElement.getAttribute('src');
                        const playPagePath = playButton.getAttribute('href');
                        const episodeInfo = episodeInfoElement ? episodeInfoElement.textContent.trim() : '';

                        // Basic checks
                        if (!playPagePath || (!playPagePath.startsWith('/') && !playPagePath.startsWith('http'))) {
                            console.warn(`[Parse ${source.name}] Skipping item due to invalid playPagePath:`, playPagePath, item);
                            return; // Skip invalid item
                        }
                        if (!coverUrl || coverUrl.includes('placeholder') || coverUrl.includes('nopic')) {
                             console.warn(`[Parse ${source.name}] Skipping item due to missing/placeholder coverUrl:`, coverUrl, item);
                             // Optionally provide a default image URL here
                             // coverUrl = '/path/to/default/image.jpg';
                             // Or just skip:
                             return;
                        }

                        const card = document.createElement('div');
                        card.className = 'result-card';
                        card.dataset.playPath = playPagePath;
                        card.dataset.title = title;
                        card.dataset.source = source.id; // Store the source ID

                        const cardImage = document.createElement('div');
                        cardImage.className = 'card-image';
                        cardImage.style.backgroundImage = `url('${coverUrl}')`;
                        cardImage.style.backgroundColor = 'var(--hover-bg-color)'; // Placeholder bg

                        if (episodeInfo) {
                            const episodeSpan = document.createElement('span');
                            episodeSpan.className = 'episode-info';
                            episodeSpan.textContent = episodeInfo;
                            cardImage.appendChild(episodeSpan);
                        }

                        const cardContent = document.createElement('div');
                        cardContent.className = 'card-content';

                        const cardTitle = document.createElement('h4');
                        cardTitle.className = 'card-title';
                        cardTitle.textContent = title;
                        cardTitle.title = title; // Tooltip for full title

                        // Add source badge
                        const sourceBadge = document.createElement('span');
                        sourceBadge.className = 'source-badge';
                        sourceBadge.textContent = source.name;
                        cardContent.appendChild(sourceBadge); // Add badge first maybe? or last


                        cardContent.appendChild(cardTitle);
                        card.appendChild(cardImage);
                        card.appendChild(cardContent);

                        card.addEventListener('click', () => {
                            loadAndPlayVideo(playPagePath, title, source.id); // Pass source ID
                        });

                        targetGrid.appendChild(card);
                        itemsAdded++;
                    } else {
                         // Only log detailed warnings if needed for debugging
                         // console.warn(`[Parse ${source.name}] Skipping item ${index+1} due to missing elements:`, { title: !!titleElement, img: !!imgElement, playBtn: !!playButton, playHref: playButton ? playButton.getAttribute('href') : 'N/A' }, item);
                    }
                } catch (e) {
                    console.error(`[Parse ${source.name}] Error processing item ${index+1}:`, e, item);
                }
            });
            console.log(`[Parse] Added ${itemsAdded} valid items from ${source.name}.`);
            return itemsAdded; // Return count of added items
        }


        // --- Video Loading (Using AI with Retry) ---
        async function loadAndPlayVideo(playPagePath, title, sourceId) {
            if (!playPagePath || !sourceId) {
                showMessage('无法获取播放页面路径或来源信息。', true);
                return;
            }
            console.log(`[Player] Attempting to play: ${title} from source: ${sourceId}, path: ${playPagePath}`);

            playerIframe.src = 'about:blank';
            playerArea.style.display = 'block';
            updatePlayerPlaceholder(`① 获取播放页: ${title} (${sourceId})...`);

            // Scroll to player
            const headerHeight = mainHeader.offsetHeight || 60;
            window.scrollTo({ top: playerArea.offsetTop - headerHeight - 20, behavior: 'smooth' });

            let playPageHtml = '';
            let streamUrl = '';

            try {
                // 1. Fetch the HTML content of the play page via proxy (with retry)
                const playDataUrl = `${PROXY_BASE_URL}/get-play-data?path=${encodeURIComponent(playPagePath)}&source=${encodeURIComponent(sourceId)}`;
                const response = await fetchWithRetry(playDataUrl); // Use retry helper
                playPageHtml = await response.text();
                console.log(`[Player] Fetched play page HTML for ${title} (length: ${playPageHtml.length})`);

                // 2. Call AI API to extract the stream URL (with retry)
                streamUrl = await callAIWithRetry(playPageHtml, title); // Use AI retry helper

                // 3. Construct final player URL and load iframe
                updatePlayerPlaceholder(`③ 加载播放器: ${title}...`);
                const finalPlayerUrl = `${EXTERNAL_PLAYER_BASE_URL}${encodeURIComponent(streamUrl)}`;
                console.log("[Player] Final Player URL:", finalPlayerUrl);

                playerIframe.src = finalPlayerUrl;

                // Hide placeholder only when iframe loads successfully
                playerIframe.onload = () => {
                    updatePlayerPlaceholder(''); // Clear placeholder text
                    playerPlaceholder.style.opacity = '0';
                     playerPlaceholderRetryInfo.style.display = 'none';
                    setTimeout(() => { playerPlaceholder.style.display = 'none'; }, 500); // Hide after fade out
                };
                playerIframe.onerror = () => {
                    console.error(`[Player] Iframe failed to load URL: ${finalPlayerUrl}`);
                    updatePlayerPlaceholder(`播放器加载失败。请检查链接或网络。`, true);
                     playerPlaceholderRetryInfo.style.display = 'none';
                };

            } catch (error) {
                console.error('[Player] 加载视频出错:', error);
                // Display the final error in the player placeholder area
                updatePlayerPlaceholder(`加载视频失败：${error.message}`, true);
                 playerPlaceholderRetryInfo.style.display = 'none'; // Ensure retry info is hidden on final failure
            }
        }


        // --- Search Handling (Multiple Sources) ---
        async function performSearch(query) {
            if (!query) {
                 if(document.activeElement.closest('form') === headerSearchForm) headerSearchInput.focus();
                 else initialSearchInput.focus();
                return;
            }

            showResultsView();
            showLoading(true);
            playerArea.style.display = 'none';
            playerIframe.src = 'about:blank';
            resultsGrid.innerHTML = ''; // Clear grid before new search

            // Update the other search input
            if (document.activeElement.closest('form') === initialSearchForm) {
                 headerSearchInput.value = query;
            } else {
                 initialSearchInput.value = query;
            }

            console.log(`[Search] Starting search for "${query}" across ${SEARCH_SOURCES.length} sources...`);

            // Create fetch promises for all sources using fetchWithRetry
            const searchPromises = SEARCH_SOURCES.map(source =>
                fetchWithRetry(`${PROXY_BASE_URL}${source.proxySearchEndpoint}?query=${encodeURIComponent(query)}`)
                    .then(response => response.text()) // Get HTML content on success
                    .then(html => ({ status: 'fulfilled', value: { html, source } })) // Wrap result with source info
                    .catch(error => ({ status: 'rejected', reason: error, source })) // Wrap error with source info
            );

            // Wait for all searches to complete (or fail)
            const results = await Promise.all(searchPromises); // Using basic Promise.all as fetchWithRetry handles individual retries

            let totalItemsAdded = 0;
            let errorsOccurred = false;
            let errorMessages = [];

            // Process results
            results.forEach(result => {
                if (result.status === 'fulfilled') {
                    console.log(`[Search] Received results from ${result.value.source.name}`);
                    try {
                        const itemsAdded = parseAndAddResults(result.value.html, result.value.source, resultsGrid);
                        totalItemsAdded += itemsAdded;
                    } catch (parseError) {
                        console.error(`[Search] Error parsing results from ${result.value.source.name}:`, parseError);
                        errorsOccurred = true;
                        errorMessages.push(`处理 ${result.value.source.name} 结果失败`);
                    }
                } else {
                    console.error(`[Search] Failed to fetch results from ${result.source.name}:`, result.reason);
                    errorsOccurred = true;
                    errorMessages.push(`搜索 ${result.source.name} 失败`);
                }
            });

            showLoading(false); // Hide loading indicator

            // Display final messages
            if (totalItemsAdded === 0) {
                if (errorsOccurred) {
                    showMessage(`搜索部分失败，未找到任何结果。\n错误: ${errorMessages.join('; ')}`, true);
                } else {
                    showMessage('在所有来源中均未找到相关的影片。', false);
                }
            } else if (errorsOccurred) {
                 // Optionally show a less intrusive message if some results were found despite errors
                 messageArea.textContent = `部分搜索来源失败: ${errorMessages.join('; ')}`;
                 messageArea.className = 'message error-message'; // Show as error but keep results visible
                 messageArea.style.display = 'block';
                 // Do not clear resultsGrid here
            } else {
                 messageArea.style.display = 'none'; // Hide message area if successful
            }
        }

        // --- Event Listeners ---
        initialSearchForm.addEventListener('submit', (event) => {
            event.preventDefault();
            const query = initialSearchInput.value.trim();
            performSearch(query);
        });

        headerSearchForm.addEventListener('submit', (event) => {
             event.preventDefault();
             const query = headerSearchInput.value.trim();
             performSearch(query);
        });

        // --- Initialization ---
        showInitialView();

    </script>
</body>
</html>
